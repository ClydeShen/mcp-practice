---
description: 
globs: 
alwaysApply: false
---
# Phase 3 - Basic Frontend Integration (Text-Based)

## 1. Phase Objective & Business Context (One NZ Agentic Voice PoC)

**Overall Goal for this Phase:** To make the AI backend (Claude 3 Sonnet + MCP) accessible to users through a basic, text-based web interface. This phase aims to provide the first tangible user experience of the agentic system, allowing for end-to-end testing from a user's perspective and demonstrating the core text-based query handling for One NZ.

**Key Business Value Proposition for this Phase:**
*   Deliver a demonstrable, interactive PoC that showcases text-based AI assistance.
*   Validate the end-to-end integration of frontend, API layer, orchestration, MCP, and LLM.
*   Provide a foundation for adding voice capabilities in the next phase.

## 2. Functional Requirements for Phase 3

*(Reference: `instruction/business-requirement.md`)*

*   **POC_FUNC_NEW_001_Text_Frontend_Interaction**:
    *   **Description**: The PoC system MUST allow users to submit text-based queries via a simple web frontend and receive textual responses that are generated by the backend.
    *   **Components_Responsible**: Frontend UI (Next.js), API Gateway, `TestOrchestratorLambda`.
    *   **Acceptance_Criteria**:
        *   User can type a query into a text input field on the frontend.
        *   Frontend sends the query to the `TestOrchestratorLambda` via an API Gateway endpoint.
        *   Frontend displays the textual response received from the `TestOrchestratorLambda`.

*   **POC_FUNC_007_E2E_Text_Flow**:
    *   **Description**: The PoC system's core components (Frontend for text I/O, API Gateway, `TestOrchestratorLambda`, Claude 3 Sonnet on Bedrock, `MCPLambda`) MUST be integrated to demonstrate a complete end-to-end text-based interaction flow, including delegation for complex queries and data lookup via MCP.
    *   **Acceptance_Criteria**: A user can type a complex query via the text frontend that requires data lookup (triggering MCP); the system processes it through all defined Phase 1-3 components, and the user receives a relevant textual answer from Claude that incorporates the mock data.

*   **POC_FUNC_008_Manageable_Use_Cases (Text Demo)**:
    *   **Description**: The PoC at this stage MUST successfully handle the predefined PoC use cases through the text interface.
    *   **Acceptance_Criteria**: System successfully handles predefined text-based PoC use cases.

*   **POC_FUNC_009_Easy_Setup_Demo (Text Demo)**:
    *   **Description**: The PoC setup and demonstration for this text-based version MUST be relatively easy.
    *   **Acceptance_Criteria**: Clear instructions exist for setting up and running the text-based demo.

## 3. Technical Implementation Tasks & Requirements for Phase 3

*(Reference: `instruction/main.md`, `instruction/technical-requriement.md`)*

### Task 3.1: Expose `TestOrchestratorLambda` via API Gateway
*   **Technical_Objective**: Create an Amazon API Gateway (HTTP API recommended for simplicity) that acts as a trigger for the `TestOrchestratorLambda`.
*   **Technical Requirements from `main.md`**:
    *   `TR_010_Secure_AWS_Service_Access` (API Gateway security considerations).
*   **Actions**:
    1.  In AWS Management Console, create a new API Gateway HTTP API.
    2.  Configure a route (e.g., `POST /orchestrate`) and integrate it with the `TestOrchestratorLambda`. Ensure the request payload from API Gateway is correctly mapped to the Lambda input format (e.g., `{ "prompt": "user's text" }`).
    3.  Deploy the API Gateway stage.
    4.  Note the API endpoint URL.
    5.  **Security**: For PoC development, an open endpoint might be acceptable for local testing, but for any wider sharing, consider API Key or IAM authorisation. For this task, focus on basic invocation.
*   **Testing_Strategy**:
    *   IaC/Deployment Verification (if IaC used for API Gateway).
    *   API Gateway Test Feature in console (send sample JSON like `{"prompt":"Kia ora"}`).
    *   Log Verification: Check `TestOrchestratorLambda` CloudWatch Logs to ensure it was invoked.
*   **Works_Properly_Indicator**: Test invocation from API Gateway console successfully triggers Lambda; Lambda's response returned via API Gateway.

### Task 3.2: Basic Frontend to Call Orchestrator API (Text Input & Output)
*   **Technical_Objective**: Develop a minimal web page in the Next.js frontend (`frontend/` package) with a text input, a submit button, and an area to display textual responses.
*   **Technical Requirements from `main.md`**:
    *   `TR_NEW_001_Text_Frontend_Interaction`.
    *   Utilise existing Next.js project with TypeScript and MUI (SP_005).
*   **Actions**:
    1.  Create a new page/component in the Next.js application.
    2.  Use MUI components for:
        *   A `TextField` for user input.
        *   A `Button` to submit the query.
        *   An area (e.g., `Typography` or `Paper` component) to display responses.
    3.  Implement state management (React Hooks) for the input text and the list of messages (query/response pairs).
    4.  On button click:
        *   Get the text from the input field.
        *   Make an asynchronous HTTP POST request (using `fetch` API or a library like `axios`) to the API Gateway endpoint URL from Task 3.1.
        *   Send the user's text in the request body, e.g., `{ "prompt": "user's query" }`.
        *   Handle the response:
            *   On success, parse the JSON response (which should contain Claude's text output from the Lambda) and display it.
            *   Handle potential errors (network issues, API errors) and display a user-friendly message.
    5.  Store the API Gateway endpoint URL in frontend environment variables (e.g., `.env.local` as `NEXT_PUBLIC_API_ENDPOINT`).
*   **Testing_Strategy**:
    *   Manual UI Test (run Next.js dev server `pnpm --filter frontend run dev`):
        *   Enter text, submit, verify request in browser network tools.
        *   Verify response displayed.
        *   Test basic error handling (e.g., if API endpoint is wrong).
*   **Works_Properly_Indicator**: User can type query, send to backend, see textual response from Claude displayed.

### Task 3.3: End-to-End Test: Frontend -> API Gateway -> `TestOrchestratorLambda` -> `MCPLambda` -> Claude
*   **Technical_Objective**: Validate the complete text-based flow from the frontend UI to Claude 3 Sonnet, including data fetching via `MCPLambda`.
*   **Actions**:
    1.  Using the developed frontend UI:
        *   Input a query designed to trigger MCP data fetching in `TestOrchestratorLambda` (e.g., "What is the plan for customer 123?").
        *   Submit the query.
    2.  Observe the response displayed on the frontend. It should reflect mock data use.
    3.  Review CloudWatch Logs for API Gateway, `TestOrchestratorLambda`, and `MCPLambda` to trace the request and verify each step's success and data flow.
    4.  Test with queries that *don't* trigger MCP to ensure that flow also works.
*   **Works_Properly_Indicator**: Frontend displays coherent response from Claude that correctly incorporates/reflects mock data fetched via `MCPLambda` when appropriate.

## 4. Key Deliverables for Phase 3

*   Deployed API Gateway HTTP API endpoint for `TestOrchestratorLambda`.
*   Source code for the basic Next.js frontend page/components for text interaction.
*   Updated frontend environment configuration for the API endpoint.
*   Demonstrable text-based end-to-end interaction with the AI system.
*   Test results (screenshots, logs) of successful end-to-end text flow.

## 5. General PoC Considerations for this Phase

*   **Demo Readiness (QS_003)**: The text-based application should be easily demonstrable.
*   **Modularity (QS_004)**: Ensure clear separation between frontend, API, and backend Lambdas.


*   Continue adherence to QS_001, QS_002, QS_005, QS_007, QS_008.